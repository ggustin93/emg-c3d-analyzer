ğŸ—ï¸ Architecture RBAC Pragmatique - EMG C3D Analyzer

  ## 1. Architecture SystÃ¨me Ã  3 Niveaux (KISS + Secure)

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                          SUPABASE (PostgreSQL)                        â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  â€¢ auth.users (Supabase Auth natif)                                  â”‚
  â”‚  â€¢ user_profiles (table existante avec role)                         â”‚
  â”‚  â€¢ RLS Policies (sÃ©curitÃ© database-level) â† PRIORITÃ‰                 â”‚
  â”‚  â€¢ Audit triggers (logging automatique)                              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â†•
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                         FASTAPI BACKEND                               â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  â€¢ JWT avec role intÃ©grÃ© (Supabase natif)                            â”‚
  â”‚  â€¢ Simple role checker (3 rÃ´les fixes)                               â”‚
  â”‚  â€¢ Permissions hardcodÃ©es (pas de DB)                                â”‚
  â”‚  â€¢ Audit via middleware lÃ©ger                                        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â†•
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                           REACT FRONTEND                              â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  â€¢ AuthContext enrichi (pas de nouveau Context)                      â”‚
  â”‚  â€¢ Role-based routing simple                                          â”‚
  â”‚  â€¢ Conditional rendering basique                                      â”‚
  â”‚  â€¢ 3 dashboards minimalistes                                          â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  ## 2. HiÃ©rarchie des RÃ´les (Simple et Claire)

  ```typescript
  enum UserRole {
    ADMIN = 'admin',          // Gestion clinique et configuration
    THERAPIST = 'therapist',  // Gestion patients et sessions
    RESEARCHER = 'researcher' // Analyse donnÃ©es anonymisÃ©es
  }
  ```

  ## 3. Matrice de Permissions SimplifiÃ©e (Phase Trial vs Production)

  ### Phase Trial (Recherche Clinique)
  | Action                   | Admin       | Therapist          | Researcher   |
  |-------------------------|-------------|--------------------|--------------|
  | Upload C3D              | âŒ          | âœ… Own patients    | âŒ           |
  | View Sessions           | âœ… All      | âœ… Own patients    | âœ… AnonymisÃ©  |
  | Add Session Notes       | âŒ          | âœ…                 | âŒ           |
  | Modify Data             | âŒ          | âŒ                 | âŒ           |
  | Export Data             | âœ…          | âŒ                 | âœ… Bulk      |
  | Configure Scoring       | âœ…          | âŒ                 | âŒ           |

  ### Phase Production (Usage Clinique)
  | Action                   | Admin       | Therapist          | Researcher   |
  |-------------------------|-------------|--------------------|--------------|
  | CRUD Patients           | âŒ          | âœ… Own             | âŒ           |
  | CRUD Sessions           | âŒ          | âœ… Own             | âŒ           |
  | Configure Scoring       | âœ…          | âœ… Per patient     | âŒ           |
  | System Settings         | âœ…          | âŒ                 | âŒ           |
  | View Analytics          | âœ… All      | âœ… Own             | âœ… AggregÃ©   |

  ## 4. ImplÃ©mentation Supabase (KISS + Secure)

  ### A. Utilisation des Tables Existantes

  ```sql
  -- âœ… La table user_profiles existe dÃ©jÃ  avec:
  -- â€¢ role (enum: ADMIN, THERAPIST, RESEARCHER)
  -- â€¢ Pas besoin de tables supplÃ©mentaires
  
  -- âœ… La relation therapist-patient existe dans:
  -- â€¢ table patients avec therapist_id
  -- â€¢ Pas besoin de table de jointure
  
  -- Audit trail simple
  CREATE TABLE IF NOT EXISTS audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    user_id UUID REFERENCES auth.users(id),
    user_role TEXT,
    action TEXT,
    table_name TEXT,
    record_id UUID,
    changes JSONB
  );
  ```

  ### B. RLS Policies SimplifiÃ©es (PrioritÃ© Absolue)

  ```sql
  -- Enable RLS sur toutes les tables
  ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
  ALTER TABLE patients ENABLE ROW LEVEL SECURITY;
  ALTER TABLE therapy_sessions ENABLE ROW LEVEL SECURITY;
  ALTER TABLE scoring_configuration ENABLE ROW LEVEL SECURITY;

  -- Policy 1: Admin voit tout (avec audit automatique)
  CREATE POLICY admin_full_access ON ALL TABLES
  FOR ALL USING (
    (SELECT role FROM user_profiles WHERE id = auth.uid()) = 'ADMIN'
  );

  -- Policy 2: Therapist voit/modifie ses patients
  CREATE POLICY therapist_own_patients ON patients
  FOR ALL USING (
    therapist_id = auth.uid()
  );

  CREATE POLICY therapist_own_sessions ON therapy_sessions
  FOR ALL USING (
    patient_id IN (
      SELECT id FROM patients WHERE therapist_id = auth.uid()
    )
  );

  -- Policy 3: Researcher read-only (donnÃ©es anonymisÃ©es via VIEW)
  CREATE POLICY researcher_read_only ON therapy_sessions
  FOR SELECT USING (
    (SELECT role FROM user_profiles WHERE id = auth.uid()) = 'RESEARCHER'
  );

  -- Vue anonymisÃ©e pour les researchers
  CREATE VIEW anonymized_sessions AS
  SELECT 
    id,
    session_date,
    -- Pas de patient_id ou therapist_id
    mvc_value,
    game_score,
    compliance_metrics
  FROM therapy_sessions;
  ```

  ## 5. ImplÃ©mentation FastAPI (Pragmatique)

  ### A. Utiliser Supabase JWT Natif

  ```python
  # backend/services/auth_service.py
  # âœ… Supabase gÃ¨re dÃ©jÃ  les JWT avec rÃ´le intÃ©grÃ©
  
  from supabase import Client
  from functools import wraps
  
  def get_current_user_role(supabase: Client, token: str):
      """Extrait le rÃ´le depuis le JWT Supabase"""
      user = supabase.auth.get_user(token)
      if user:
          # Le rÃ´le vient de user_profiles
          profile = supabase.table('user_profiles').select('role').eq('id', user.id).single().execute()
          return profile.data['role'] if profile.data else None
      return None
  ```

  ### B. Simple Role Checker (KISS)

  ```python
  # backend/api/dependencies.py
  from fastapi import Depends, HTTPException, Header
  from typing import Optional
  
  # Permissions hardcodÃ©es pour 3 rÃ´les (pas de DB)
  PERMISSIONS = {
      'ADMIN': ['scoring:write', 'settings:write', 'reports:all'],
      'THERAPIST': ['patients:write', 'sessions:write', 'reports:own'],
      'RESEARCHER': ['reports:read', 'analytics:read']
  }
  
  def check_permission(required: str):
      """DÃ©corateur simple pour vÃ©rifier les permissions"""
      def decorator(func):
          @wraps(func)
          async def wrapper(*args, **kwargs):
              # Le rÃ´le vient du header Authorization
              token = kwargs.get('authorization')
              role = get_current_user_role(supabase, token)
              
              if required not in PERMISSIONS.get(role, []):
                  raise HTTPException(403, "Permission denied")
              
              return await func(*args, **kwargs)
          return wrapper
      return decorator
  
  # Usage simple
  @router.put("/scoring/configuration")
  @check_permission("scoring:write")
  async def update_scoring_config(config: ScoringConfig):
      # Seuls les ADMIN arrivent ici
      pass
  ```

  ### C. Audit Middleware LÃ©ger

  ```python
  # backend/middleware/audit.py
  from fastapi import Request
  import json
  from datetime import datetime
  
  async def audit_middleware(request: Request, call_next):
      """Log les Ã©critures pour compliance"""
      if request.method in ["POST", "PUT", "DELETE"]:
          # Log basique dans la DB
          body = await request.body()
          audit_entry = {
              "timestamp": datetime.utcnow(),
              "user_id": request.headers.get("user-id"),
              "method": request.method,
              "path": request.url.path,
              "body": json.loads(body) if body else None
          }
          # Enregistrer dans audit_log via Supabase
          await log_to_audit(audit_entry)
      
      response = await call_next(request)
      return response
  ```

  ## 6. ImplÃ©mentation React (Minimaliste)

  ### A. AuthContext Enrichi (Pas de nouveau Context!)

  ```typescript
  // frontend/src/contexts/AuthContext.tsx
  // âœ… Enrichir l'existant au lieu de crÃ©er un nouveau Context
  
  interface AuthContextType {
    authState: AuthState
    login: (credentials: LoginCredentials) => Promise<AuthResponse<Session>>
    logout: () => Promise<AuthResponse<void>>
    // ... existing methods ...
    
    // ğŸ†• Ajouts RBAC simples
    userRole: 'admin' | 'therapist' | 'researcher' | null
    canAccess: (permission: string) => boolean
  }
  
  // Dans AuthProvider, ajouter:
  const userRole = authState.profile?.role || null;
  
  const canAccess = useCallback((permission: string) => {
    const permissions = {
      'admin': ['all'],
      'therapist': ['patients', 'sessions', 'own-reports'],
      'researcher': ['analytics', 'anonymized-data']
    };
    
    if (!userRole) return false;
    if (userRole === 'admin') return true; // Admin peut tout
    return permissions[userRole]?.includes(permission) || false;
  }, [userRole]);
  ```

  ### B. Routing BasÃ© sur le RÃ´le

  ```tsx
  // frontend/src/App.tsx
  import { Navigate } from 'react-router-dom';
  import { useAuth } from './contexts/AuthContext';
  
  // 3 Dashboards minimalistes
  const AdminDashboard = lazy(() => import('./dashboards/AdminDashboard'));
  const TherapistDashboard = lazy(() => import('./dashboards/TherapistDashboard'));
  const ResearcherDashboard = lazy(() => import('./dashboards/ResearcherDashboard'));
  
  function App() {
    const { isAuthenticated, userRole } = useAuth();
    
    // Redirection aprÃ¨s login basÃ©e sur le rÃ´le
    const getDashboard = () => {
      if (!isAuthenticated) return <LoginPage />;
      
      switch(userRole) {
        case 'admin':
          return <AdminDashboard />;
        case 'therapist':
          return <TherapistDashboard />;
        case 'researcher':
          return <ResearcherDashboard />;
        default:
          return <Navigate to="/login" />;
      }
    };
    
    return (
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route path="/dashboard/*" element={getDashboard()} />
        <Route path="/" element={<Navigate to="/dashboard" />} />
      </Routes>
    );
  }
  ```

  ### C. Conditional Rendering Simple

  ```tsx
  // frontend/src/components/settings/ScoringWeightsSettings.tsx
  import { useAuth } from '../../contexts/AuthContext';
  
  export function ScoringWeightsSettings() {
    const { userRole } = useAuth();
    const isAdmin = userRole === 'admin';
    const isTherapist = userRole === 'therapist';
    
    return (
      <Card>
        <CardHeader>
          <CardTitle>
            Scoring Configuration
            {!isAdmin && <Badge variant="outline">Read Only</Badge>}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Slider
            value={[weights.compliance * 100]}
            onValueChange={isAdmin ? updateWeight : undefined}
            disabled={!isAdmin}
            className={!isAdmin ? "opacity-50" : ""}
          />
          
          {isTherapist && (
            <Alert>
              <Info className="h-4 w-4" />
              <AlertDescription>
                Contact admin to modify scoring weights
              </AlertDescription>
            </Alert>
          )}
        </CardContent>
      </Card>
    );
  }
  ```

  ### D. Les 3 Dashboards Minimalistes

  ```tsx
  // frontend/src/dashboards/AdminDashboard.tsx
  export function AdminDashboard() {
    return (
      <div className="p-6">
        <h1>Admin Dashboard</h1>
        <div className="grid grid-cols-2 gap-4">
          <Card>
            <CardTitle>âš™ï¸ System Settings</CardTitle>
            <ScoringWeightsSettings />
          </Card>
          <Card>
            <CardTitle>ğŸ‘¥ User Management</CardTitle>
            <UserList />
          </Card>
          <Card>
            <CardTitle>ğŸ“Š Site Statistics</CardTitle>
            <GlobalMetrics />
          </Card>
          <Card>
            <CardTitle>ğŸ” Audit Logs</CardTitle>
            <AuditTrail />
          </Card>
        </div>
      </div>
    );
  }
  
  // frontend/src/dashboards/TherapistDashboard.tsx
  export function TherapistDashboard() {
    return (
      <div className="p-6">
        <h1>Therapist Dashboard</h1>
        <div className="grid grid-cols-2 gap-4">
          <Card>
            <CardTitle>ğŸ‘¥ My Patients</CardTitle>
            <PatientList ownOnly={true} />
          </Card>
          <Card>
            <CardTitle>ğŸ“ˆ Session Results</CardTitle>
            <SessionMetrics patientFilter="own" />
          </Card>
          <Card>
            <CardTitle>ğŸ“ Clinical Notes</CardTitle>
            <NotesEditor />
          </Card>
          <Card>
            <CardTitle>ğŸ“¤ Upload C3D</CardTitle>
            <C3DUploader />
          </Card>
        </div>
      </div>
    );
  }
  
  // frontend/src/dashboards/ResearcherDashboard.tsx  
  export function ResearcherDashboard() {
    return (
      <div className="p-6">
        <h1>Researcher Dashboard</h1>
        <div className="grid grid-cols-2 gap-4">
          <Card>
            <CardTitle>ğŸ“Š Study Analytics</CardTitle>
            <PopulationMetrics anonymized={true} />
          </Card>
          <Card>
            <CardTitle>ğŸ“ˆ Statistical Analysis</CardTitle>
            <ResearchCharts />
          </Card>
          <Card>
            <CardTitle>ğŸ“‘ Export Center</CardTitle>
            <DataExporter anonymized={true} />
          </Card>
          <Card>
            <CardTitle>ğŸ” Trends</CardTitle>
            <TrendAnalysis />
          </Card>
        </div>
      </div>
    );
  }
  ```

  ## 7. Checklist d'ImplÃ©mentation Pragmatique

  ### âœ… Phase 1: Foundation (Jour 1)
  - [ ] Git: CrÃ©er branche `feature/rbac-implementation`
  - [ ] DB: Activer RLS sur les tables principales
  - [ ] DB: CrÃ©er les policies RLS simples
  - [ ] DB: CrÃ©er table audit_log
  - [ ] Backend: Ajouter role checker simple
  
  ### âœ… Phase 2: Integration (Jour 2)
  - [ ] Frontend: Enrichir AuthContext avec role
  - [ ] Frontend: Modifier authService â†’ user_profiles
  - [ ] Frontend: CrÃ©er 3 dashboards minimalistes
  - [ ] Frontend: ImplÃ©menter routing par rÃ´le
  - [ ] Backend: Tests RBAC basiques
  
  ### âœ… Phase 3: Polish (Jour 3)
  - [ ] UI: Fix z-index issues
  - [ ] UI: Conditional rendering sur settings
  - [ ] Tests: E2E pour chaque rÃ´le
  - [ ] Docs: Update API documentation
  - [ ] Deploy: Test en staging

  ## 8. Principes KISS AppliquÃ©s

  1. **Pas de sur-ingÃ©nierie**: 
     - âŒ Pas de table permissions (3 rÃ´les fixes)
     - âŒ Pas de RoleContext sÃ©parÃ©
     - âœ… Utiliser l'existant (user_profiles, AuthContext)
  
  2. **SÃ©curitÃ© par dÃ©faut**:
     - âœ… RLS dÃ¨s le dÃ©but (database-level)
     - âœ… Audit automatique via triggers
     - âœ… JWT Supabase natif
  
  3. **Pragmatisme**:
     - âœ… Permissions hardcodÃ©es (pas de DB)
     - âœ… 3 dashboards simples (pas de composants complexes)
     - âœ… Tests minimaux mais critiques

  ## 9. DiffÃ©rences avec l'Approche Initiale

  | Aspect | Plan Initial (Ami) | Approche Pragmatique |
  |--------|-------------------|---------------------|
  | Tables | +3 nouvelles tables | 0 nouvelle table |
  | Contexts | RoleContext sÃ©parÃ© | AuthContext enrichi |
  | Permissions | DB + classes | Dictionnaire Python |
  | Dashboards | Complexes | 3 cards simples |
  | RLS | Phase 2 | DÃ¨s le dÃ©but |
  | Tests | Complets | Critiques seulement |
  
  Cette approche combine la **soliditÃ© architecturale** avec le **pragmatisme KISS** demandÃ©.