Of course. This is the perfect request. A plan without context is just a list of instructions; a plan *with* context is a strategy. It empowers the developer to understand the "why" behind each action, make intelligent decisions when faced with unexpected issues, and explain the process to the rest of the team.

Here is the complete, context-rich architectural playbook for transforming your project into a professional monorepo.

---

### **Architectural Playbook: Unifying Ghostly+ into a Cohesive Monorepo**

**Project:** GHOSTLY+ Web Dashboard
**From:** Two separate repositories (`ghostly-plus-dashboard` and `emg-c-analyzer`).
**To:** A single, unified monorepo containing a shared backend, two distinct frontend applications (Therapist and Researcher), and a foundation for shared code.

#### **Full Context: The Strategic "Why"**

Before we dive into the "how," it's crucial to understand the architectural principles guiding this migration.

1.  **Principle 1: One Product, Two Interfaces.** We are establishing that the Therapist Dashboard and the Researcher Analyzer are not separate projects, but two specialized views of the **same underlying product**. A monorepo is the natural technical expression of this business reality. It simplifies dependency management and ensures consistency.

2.  **Principle 2: Preserve What Works, Replace What's Inferior.** The `emg-c-analyzer` project has a demonstrably superior backend with its advanced, stateless analysis pipeline. The `ghostly-plus-dashboard` project has the better production-ready structure (Docker Compose with Nginx, documentation, CI). Our strategy is to ** surgically combine the best parts of both**, not to painstakingly merge conflicting code. This means the advanced backend from `emg-c-analyzer` will become the *single source of truth* for our API.

3.  **Principle 3: Migrate Structure First, Logic Later.** The biggest risk in any migration is changing too many things at once. Our plan strictly separates these concerns. **Phase 1 and 2 are purely structural.** We will physically move files and get everything running in the new structure *before* we even think about refactoring or sharing a single line of application logic. This isolates risk and makes debugging a thousand times easier.

4.  **Principle 4: Unify Tooling for a Cohesive Developer Experience (DX).** A monorepo should feel like a single, cohesive project to a developer. We will adapt the best startup script (`start_dev.sh`) to manage the entire ecosystem from one command and use `pnpm` workspaces to make dependency management seamless.

With this context in mind, let's proceed with the detailed, step-by-step plan.

---

#### **PHASE 0 â€” Project Unification & Cleanup (Est. Duration: 1-2 hours)**

ğŸ¯ **Goal:** Establish a single source of truth for all project-level files and configurations by selecting the "best" version from each repository. This is done inside your main `ghostly-plus-dashboard` repository.

ğŸ§  **Rationale:** This phase prevents confusion and ensures we start from a clean, intentional foundation. We are making deliberate choices about which scripts, configurations, and documentation will serve the unified project going forward.

ğŸ“ **Detailed Steps:**

1.  **Open the `ghostly-plus-dashboard` project.** This will be our monorepo base.
2.  **Perform the "Unification" by replacing or merging files:**
    *   **Backend:** **Delete** the entire `backend/` directory inside `ghostly-plus-dashboard`.
        *   *Reason:* We are fully committing to the superior `emg-c-analyzer` backend.
    *   **Startup Script:** **Delete** the `scripts/check-services.sh` and `scripts/restart-services.sh` if they exist. **Copy** the `start_dev.sh` from the root of `emg-c-analyzer` to the root of `ghostly-plus-dashboard`.
        *   *Reason:* The `emg-c-analyzer` script is a more robust, professional tool for managing development processes. We will adapt it in Phase 2.
    *   **Documentation (`docs/`):** **Merge the best of both.** Create a new, clean `docs/` folder. Systematically review the `docs/` from both projects and copy over the most up-to-date and relevant files (`architecture.md`, `database_schema.md`, etc.). Discard anything that is now obsolete.
    *   **CI/CD (`.github/`):** Keep the existing workflow file from `ghostly-plus-dashboard`. We will adapt it later to handle the monorepo structure.

âœ… **Success Criteria for Phase 0:** Your `ghostly-plus-dashboard` repository now contains the definitive versions of all project-level files, and the old, redundant code (like the original backend) has been removed.

---

#### **PHASE 1 â€” Preparation: Building the Foundation (Est. Duration: 2-3 hours)**

ğŸ¯ **Goal:** Physically restructure the project into the monorepo layout and install all dependencies using `pnpm` workspaces.

ğŸ§  **Rationale:** We are creating the "scaffolding" of our new monorepo. `pnpm` workspaces will allow our separate applications to be aware of each other and any shared packages we create later. The `pnpm install` command at the end validates that the basic structure is correct.

ğŸ“ **Detailed Steps:**

1.  **In the `ghostly-plus-dashboard` root, create the new folder structure:**
    ```bash
    mkdir -p apps/therapist-frontend apps/researcher-frontend apps/backend-api packages/shared-ui
    ```
2.  **Delete the original `frontend/` folder** (if you haven't already).
3.  **Create the Monorepo Configuration Files at the root:**
    *   `pnpm-workspace.yaml`:
        ```yaml
        packages:
          - "apps/*"
          - "packages/*"
        ```
    *   Root `package.json`:
        ```json
        {
          "name": "ghostly-plus-monorepo",
          "private": true,
          "scripts": {
            "dev:therapist": "pnpm --filter therapist-frontend dev",
            "dev:researcher": "pnpm --filter researcher-frontend dev"
          }
        }
        ```
4.  **Copy the Application Code into the new structure:**
    *   **Therapist Frontend:** Copy the code from your *original* `ghostly-plus-dashboard/frontend` into `apps/therapist-frontend`.
    *   **Researcher Frontend:** Copy the code from `emg-c-analyzer/frontend` into `apps/researcher-frontend`.
    *   **Backend API:** Copy the code from `emg-c-analyzer/backend` into `apps/backend-api`.

5.  **Install All Dependencies from the Root:**
    ```bash
    pnpm install
    ```

âœ… **Success Criteria for Phase 1:** The project now has the `apps/` and `packages/` structure, all code is in place, and `pnpm install` completes successfully.

---

#### **PHASE 2 â€” Adapting Tooling & Local Launch (Est. Duration: 3-4 hours)**

ğŸ¯ **Goal:** Adapt the development tools (`vite.config.ts`, `start_dev.sh`) to the new monorepo structure and successfully launch all three applications concurrently from a single command.

ğŸ§  **Rationale:** A monorepo is only effective if the developer experience is smooth. A single, powerful startup script and correctly configured development servers are essential for productivity and for making the project feel like a single, unified system.

ğŸ“ **Detailed Steps:**

1.  **Configure Frontend Servers:**
    *   In both `apps/researcher-frontend/vite.config.ts` and `apps/therapist-frontend/vite.config.ts`, ensure they have unique ports and a proxy configuration to talk to the backend without CORS errors.
        ```typescript
        // Example for apps/researcher-frontend/vite.config.ts
        server: {
          port: 5173, // Researcher Port
          proxy: { '/api': 'http://localhost:8000' }
        }
        ```
        ```typescript
        // Example for apps/therapist-frontend/vite.config.ts
        server: {
          port: 5174, // Therapist Port
          proxy: { '/api': 'http://localhost:8000' }
        }
        ```

2.  **Adapt the `start_dev.sh` Script for Monorepo Control:**
    *   Replace the `start_dev.sh` at your project root with this monorepo-aware version. The comments explain the changes.

    ```bash
    #!/bin/bash
    # MONOREPO-ADAPTED Development Startup Script

    # --- Configuration (remains the same) ---
    set -e; set -u; set -o pipefail
    # ... (all color and logging functions remain the same) ...
    readonly BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
    readonly LOG_DIR="$BASE_DIR/logs"
    readonly PID_FILE="$BASE_DIR/.dev_pids"
    
    # --- Cleanup Function (remains the same) ---
    cleanup() { # ... same logic to kill all PIDs from the file ... 
    }

    # --- ADAPTED STARTUP FUNCTIONS ---

    start_backend() {
        log_header "Starting Backend API Server"
        # CHANGE: Navigate into the specific app directory
        local backend_dir="$BASE_DIR/apps/backend-api"
        cd "$backend_dir"

        log_info "Ensuring backend dependencies are installed via Poetry..."
        poetry install --no-root --no-interaction

        log_info "Starting Uvicorn server for the backend on port 8000..."
        poetry run uvicorn main:app --host 0.0.0.0 --port 8000 --reload \
            >"$LOG_DIR/backend.log" 2>"$LOG_DIR/backend.error.log" &
        echo $! > "$PID_FILE" # Start a new PID file with the first PID
        log_success "Backend server started with PID $!."
        cd "$BASE_DIR" # CHANGE: Return to the root directory
    }

    start_frontends() {
        log_header "Starting Frontend Development Servers"
        
        # CHANGE: Use pnpm --filter to target specific apps from the root
        log_info "Starting Researcher Frontend (Port 5173)..."
        pnpm --filter researcher-frontend dev \
            >"$LOG_DIR/researcher.log" 2>"$LOG_DIR/researcher.error.log" &
        echo $! >> "$PID_FILE" # Append PID to the file
        log_success "Researcher Frontend started with PID $!."

        log_info "Starting Therapist Frontend (Port 5174)..."
        pnpm --filter therapist-frontend dev \
            >"$LOG_DIR/therapist.log" 2>"$LOG_DIR/therapist.error.log" &
        echo $! >> "$PID_FILE" # Append PID to the file
        log_success "Therapist Frontend started with PID $!."
    }

    # --- Main Execution ---
    main() {
        trap cleanup SIGINT SIGTERM
        mkdir -p "$LOG_DIR"
        rm -f "$PID_FILE"

        start_backend
        start_frontends

        log_header "Development Environment is Running"
        echo "ğŸ”µ Researcher App: http://localhost:5173"
        echo "ğŸŸ¢ Therapist App:  http://localhost:5174"
        echo "âš«ï¸ Backend API:    http://localhost:8000"
        echo "Press Ctrl+C to stop all services."

        wait # Wait for any background process to exit before the script ends
    }

    main
    ```

3.  **Run the Monorepo:**
    ```bash
    chmod +x start_dev.sh
    ./start_dev.sh
    ```

âœ… **Success Criteria for Phase 2:** The single script launches all three services. You can open `localhost:5173` and `localhost:5174`, and both applications function and can make successful API calls to the backend.

---

#### **PHASE 3 â€” Progressive Refactoring & Code Sharing (Ongoing)**

ğŸ¯ **Goal:** Gradually eliminate code duplication by moving common components, hooks, and types into the `packages/` directories.

ğŸ§  **Rationale:** This is the long-term payoff of the monorepo. It ensures consistency, reduces maintenance overhead, and speeds up future development. We do this *progressively* to avoid a large, risky rewrite.

ğŸ“ **Your First Refactoring Task (Example):**

1.  **Identify:** The `Button.tsx` component exists in both frontends.
2.  **Create Shared Package:** Set up `packages/shared-ui/package.json`.
3.  **Move & Export:** Move the `Button.tsx` code into `packages/shared-ui/src/components/Button.tsx` and export it from `packages/shared-ui/src/index.ts`.
4.  **Configure TypeScript:** Create a `tsconfig.base.json` at the root with `paths` aliases (`"@shared-ui/*": ["packages/shared-ui/src/*"]`). Make the `tsconfig.json` in each frontend `extend` this base config.
5.  **Refactor:** Delete the local `Button.tsx` files and update the imports in your application code to `import { Button } from '@shared-ui/components/Button';`.

This plan provides the full strategic context and transforms the migration into a series of small, manageable, and low-risk steps.


ğŸŒ³ ghostly-plus-dashboard/ (Your Project Root)
â”œâ”€â”€ ğŸ“‚ apps/                      # Directory for all deployable applications
â”‚   â”œâ”€â”€ ğŸš€ researcher-frontend/   # The Researcher App (from emg-c-analyzer)
â”‚   â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”œâ”€â”€ src/                  # All React code lives here
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â””â”€â”€ main.tsx
â”‚   â”‚   â”œâ”€â”€ index.html            # Vite entry point
â”‚   â”‚   â”œâ”€â”€ package.json          # App-specific dependencies
â”‚   â”‚   â”œâ”€â”€ tsconfig.json         # Extends the root tsconfig
â”‚   â”‚   â””â”€â”€ vite.config.ts        # Vite config (port 5173, proxy)
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸš€ therapist-frontend/    # The Therapist App (your original frontend)
â”‚   â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ contexts/
â”‚   â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â””â”€â”€ main.tsx
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”‚   â””â”€â”€ vite.config.ts        # Vite config (port 5174, proxy)
â”‚   â”‚
â”‚   â””â”€â”€ ğŸš€ backend-api/           # The unified Backend API (from emg-c-analyzer)
â”‚       â”œâ”€â”€ app/                  # FastAPI application code
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ api.py
â”‚       â”‚   â”œâ”€â”€ models.py
â”‚       â”‚   â”œâ”€â”€ processor.py
â”‚       â”‚   â””â”€â”€ main.py
â”‚       â”œâ”€â”€ tests/
â”‚       â”œâ”€â”€ Dockerfile            # Docker config for the backend
â”‚       â”œâ”€â”€ pyproject.toml        # Poetry dependencies for the backend
â”‚       â””â”€â”€ requirements.txt
â”‚
â”œâ”€â”€ ğŸ“‚ packages/                  # Directory for shared, non-deployable code
â”‚   â”œâ”€â”€ ğŸ“¦ shared-ui/             # Shared React components
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Button.tsx    # Example: A button used by both frontends
â”‚   â”‚   â”‚   â””â”€â”€ index.ts          # Exports all shared components
â”‚   â”‚   â”œâ”€â”€ package.json          # Defines this as the "@ghostly/shared-ui" package
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“¦ shared-utils/          # Shared utility functions (e.g., formatters)
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ package.json          # Defines this as the "@ghostly/shared-utils" package
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“¦ shared-types/          # (Future) Shared TypeScript types for API contracts
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ index.ts
â”‚       â”‚   â””â”€â”€ emg.ts
â”‚       â””â”€â”€ package.json
â”‚
â”œâ”€â”€ ğŸ“‚ .github/                   # CI/CD workflows (kept and will be adapted)
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ ci.yml
â”‚
â”œâ”€â”€ ğŸ“‚ docs/                      # Merged and unified project documentation
â”‚   â”œâ”€â”€ architecture.md
â”‚   â””â”€â”€ database_schema.md
â”‚
â”œâ”€â”€ ğŸ“‚ supabase_config/           # Your Supabase setup (kept as is)
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ node_modules/                 # Single, root node_modules managed by pnpm (DO NOT COMMIT)
â”œâ”€â”€ .env                          # Root environment variables (DO NOT COMMIT)
â”œâ”€â”€ .gitignore
â”œâ”€â”€ docker-compose.yml            # Kept and will be adapted for the new structure
â”œâ”€â”€ package.json                  # The ROOT package.json that controls the monorepo
â”œâ”€â”€ pnpm-workspace.yaml           # The file that DEFINES this as a pnpm monorepo
â”œâ”€â”€ README.md                     # Your updated project README
â”œâ”€â”€ start_dev.sh                  # The new, unified startup script
â””â”€â”€ tsconfig.base.json            # The MASTER TypeScript config with shared paths